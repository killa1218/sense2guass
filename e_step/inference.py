# coding=utf8import syssys.path.append('../')from loss import *from options import Options as optimport tensorflow as tffrom loss import skipGramWindowLoss# from tensorflow.nn import sigmoid as act# from tensorflow.nn import tanh as actfrom tensorflow.nn import relu as actfrom m_step.utils.distance import distimport pprintpp = pprint.PrettyPrinter(indent = 4)minLoss = float('inf')def dfs(stc, n, sLabel, assign):    global minLoss    if n == len(stc):        return    with tf.Session() as sess:        for i in range(stc[n].senseNum):            sLabel[n] = i            cur = sess.run(avgSkipGramLoss(stc, sLabel))            if cur < minLoss:                minLoss = cur                assign = sLabel            dfs(stc, n + 1, sLabel, assign)def violentInference(stc):    ''' Inference the senses using DFS '''    senseLabel = [0] * len(stc)    assign = []    dfs(stc, 0, senseLabel, assign)    return assigndef dfs(stc, mid):    l = len(stc)    fullWindowSize = 0    if l < opt.windowSize * 2 + 1:        fullWindowSize = l    elif mid + opt.windowSize >= l:        fullWindowSize = l - mid + opt.windowSize    elif mid - opt.windowSize < 0:        fullWindowSize = mid + opt.windowSize    else:        fullWindowSize = opt.windowSize * 2 + 1    with tf.Session() as sess:        stack = [0] * fullWindowSize        yield stack, sess.run(skipGramWindowLoss(stc, stack, mid)), mid        while True:            if (len(stack) == 0):                break            else:                if stack[-1] == stc[len(stack) - 1].senseNum - 1:                    stack.pop()                else:                    stack[-1] += 1                    stack += [0] * (len(stc) - len(stack))                    yield stack, sess.run(skipGramWindowLoss(stc, stack, mid)), middef dpInference(stc, vocab):    v = {}  # Record Intermediate Probability    assign = []  # Result of word senses in a sentence    for a, l, m in dfs(stc, opt.windowSize):        # v[tuple(a)] = dict(loss = l, mid = m)        v[tuple(a)] = l    for i in range(opt.windowSize + 1, len(stc)):        minLoss = float('inf')  # Minimum loss        newWord = stc[i + opt.windowSize if i + opt.windowSize < len(stc) else len(stc) - 1]        tmpV = {}        for j in v:            prevAssign = list(j)            # prevLoss = v[j]['loss']            prevLoss = v[j]            for j in range(0, newWord.senseNum):                curAssign = prevAssign + [j]                curLoss = prevLoss + skipGramWindowLoss(stc, curAssign, i)                tmpV[tuple(curAssign)] = curLoss                if curAssign < minLoss:                    minLoss = curLoss                    assign = curAssign        print assign        del(v)        for j in tmpV:            if j[i - opt.windowSize - 1] == assign[i - opt.windowSize - 1]:                v[j] = tmpV[j]    return assign